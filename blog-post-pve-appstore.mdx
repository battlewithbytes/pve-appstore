---
title: "Why I Built a Proxmox App Store (And Why Your Install Scripts Shouldn't Run on the Hypervisor)"
slug: "pve-appstore-secure-proxmox-app-deployment"
date: "2026-02-11"
excerpt: "A web-based app store for Proxmox that deploys LXC containers with a Python SDK — where provisioning scripts never touch the hypervisor."
tags: ["proxmox", "lxc", "homelab", "security", "python", "self-hosting", "devops"]
author: "ril3y"
coverImage: "/images/blog/pve-appstore/cover.png"
---

import RadixTabs from '../../../components/RadixTabs'
import DropCap from '../../../components/DropCap'

<DropCap>
If you run Proxmox, you've probably used the community helper scripts. Paste a one-liner, get a fully configured LXC container. Brilliant — until you realize that single command just executed 8 remote bash scripts as root on your hypervisor. An XDA article published this week laid this out in uncomfortable detail, drawing parallels to the xz Utils supply chain attack. I read it and thought: this is exactly the problem I've been building a solution for.
</DropCap>

This post introduces the **PVE App Store** — an open-source, self-hosted app store for Proxmox that gives you one-click LXC deployments with a fundamentally different security model. The key difference: **provisioning scripts run inside the container, never on your hypervisor.**

## The Problem With `curl | bash` on Your Hypervisor

Let's look at how the community scripts work. You run this on your Proxmox host:

```bash
bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/ct/ollama.sh)"
```

That one command triggers a chain of **8 remote script downloads**, all executing with root privileges on the machine that controls every VM and container in your homelab:

| Step | Script | Runs On |
|------|--------|---------|
| 1 | `ct/ollama.sh` | Proxmox host (root) |
| 2 | `misc/build.func` | Proxmox host (root) |
| 3 | `misc/core.func` | Proxmox host (root) |
| 4 | `misc/error_handler.func` | Proxmox host (root) |
| 5 | `misc/api.func` | Proxmox host (root) |
| 6 | `misc/tools.func` | Proxmox host (root) |
| 7 | `install/ollama-install.sh` | Inside container |
| 8 | `misc/install.func` | Inside container |

Six of those eight scripts run **on the hypervisor**. If any one of them is compromised — through a malicious commit, a hijacked GitHub account, or a supply chain attack — the attacker has root access to your entire Proxmox node. Every VM, every container, every storage pool.

> The xz Utils backdoor took 3 years of social engineering to insert. A Proxmox helper script commit takes one merged PR.

## How PVE App Store Works

Our architecture inverts this model. The Go binary runs on the host and uses the **Proxmox REST API** to create containers. The provisioning script — the part written by app authors, the part you can't fully trust — runs exclusively **inside the LXC container**.

```
┌──────────────────────────────────────────────────┐
│  PROXMOX HOST                                    │
│                                                  │
│  ┌──────────────────────┐                        │
│  │  pve-appstore (Go)   │──── Proxmox REST API   │
│  │  compiled binary     │     (create CT, start)  │
│  └──────────┬───────────┘                        │
│             │                                    │
│             │ pct push install.py                 │
│             │ pct exec python3 install.py         │
│             ▼                                    │
│  ┌──────────────────────┐                        │
│  │  LXC Container       │  ◄── script runs HERE  │
│  │  ┌────────────────┐  │                        │
│  │  │  Python SDK     │  │                        │
│  │  │  install.py     │  │                        │
│  │  └────────────────┘  │                        │
│  └──────────────────────┘                        │
└──────────────────────────────────────────────────┘
```

If `install.py` contains malicious code, it can only damage the container it runs in. `pct destroy` and start over. Your hypervisor, your other VMs, your data — untouched.

## The Permission Manifest

Every app in the catalog ships with an `app.yml` that declares **exactly what the script is allowed to do**. Here's a real example from our Ollama app:

```yaml
permissions:
  packages: []
  installer_scripts: ["https://ollama.ai/install.sh"]
  urls: ["http://127.0.0.1:*"]
  paths: ["/etc/systemd/", "/usr/share/ollama/"]
  services: [ollama]
  users: [ollama]
  commands: [ollama]
```

This is a capability manifest. Before any SDK method runs, it checks the permission allowlist. A reviewer can glance at this YAML and immediately ask: "Why does a note-taking app need access to `/etc/ssh/`?" No need to read through hundreds of lines of bash.

Compare this to the community scripts, which have **no permission model at all**. Every script can do anything, and the only safeguard is hoping someone read the code before merging it.

## The Python SDK

Instead of raw bash, provisioning scripts use a Python SDK with structured methods that map to real operations:

<RadixTabs
  tabs={[
    {
      label: "Ollama",
      content: `\`\`\`python
class OllamaApp(BaseApp):
    def install(self):
        api_port = self.inputs.string("api_port", "11434")
        models_path = self.inputs.string("models_path",
            "/usr/share/ollama/.ollama/models")

        # Detect GPU inside the container
        gpu_type = self._detect_gpu()

        # Install via upstream installer
        self.run_installer_script("https://ollama.ai/install.sh")

        # Configure systemd
        self.create_dir("/etc/systemd/system/ollama.service.d")
        self.write_config(
            "/etc/systemd/system/ollama.service.d/override.conf",
            SYSTEMD_OVERRIDE,
            api_port=api_port,
            models_path=models_path,
        )

        self.restart_service("ollama")
\`\`\``
    },
    {
      label: "Home Assistant",
      content: `\`\`\`python
class HomeAssistantApp(BaseApp):
    def install(self):
        http_port = self.inputs.string("http_port", "8123")

        self.apt_install(
            "python3", "python3-venv", "python3-pip",
            "libffi-dev", "libssl-dev",
        )

        self.create_user("homeassistant",
            system=True, home="/opt/homeassistant")
        self.create_venv("/opt/homeassistant/venv")
        self.pip_install("homeassistant",
            venv="/opt/homeassistant/venv")

        self.create_service("homeassistant",
            exec_start="/opt/homeassistant/venv/bin/hass -c /config",
            user="homeassistant")
\`\`\``
    }
  ]}
/>

Every `self.apt_install()`, `self.create_user()`, `self.download()` call is checked against the declared permissions before executing. The SDK provides:

- **`apt_install()` / `apk_install()` / `pkg_install()`** — OS-aware package management
- **`pip_install()`** — Python packages, with optional venv support
- **`create_user()`** — system user creation
- **`create_dir()`** — directory creation with ownership
- **`download()`** — file downloads (URL must be in permissions)
- **`write_config()`** — templated config files with variable substitution
- **`create_service()`** — systemd/OpenRC service creation
- **`run_command()`** — escape hatch for anything else (command must be declared)
- **`wait_for_http()`** — health check polling before continuing

Every method is auditable, every action is declared. No surprise `curl | bash` chains.

## Dockerfile Import

Most self-hosted apps ship as Docker images. Rather than starting from scratch, the PVE App Store can **import a Dockerfile** and generate a working LXC provisioning script.

Point the import wizard at a Docker Hub image or GitHub Dockerfile URL. The system:

1. **Fetches the Dockerfile** and recursively resolves the `FROM` chain (parent images)
2. **Parses everything**: packages, ports, volumes, env vars, COPY instructions, users, downloads, startup commands
3. **Generates `app.yml`** with all inputs, permissions, and LXC defaults pre-populated
4. **Generates `install.py`** using the Python SDK — not bash
5. **Opens both in a code editor** so you can review and customize before deploying

For a LinuxServer image like SWAG, this means the system follows the chain:

```
SWAG Dockerfile
  └── FROM ghcr.io/linuxserver/baseimage-alpine-nginx
        └── FROM ghcr.io/linuxserver/baseimage-alpine:3.21
              └── FROM alpine:3.21 (terminal — base OS detected)
```

Packages from all layers are merged, deduped, and grouped. COPY instructions that deploy config files are converted to `git clone` + `cp` calls with the source repo. Commands with shell operators (`>>`, `|`, `$()`) are wrapped in `sh -c` rather than naively split into broken subprocess args.

The command categorization rules are stored in a human-readable YAML file — not embedded in code:

```yaml
# command_rules.yml — add patterns here, no Go changes needed
noise:
  exact: ["true", ":", "cd"]
  contains:
    - "rm -rf /var/lib/apt"
    - "rm -rf /var/cache"
    - "apt-get clean"
    - "apt-get autoremove"
    - "/root-out/"

command_types:
  - type: sed
    prefix: "sed "
  - type: chmod
    prefix: "chmod "
  - type: chown
    prefix: "chown "

shell_operators: [">>", "> /", " | ", "$("]
```

## Developer Mode

The app store includes a full developer environment for building new apps:

- **Web-based code editor** (CodeMirror 6) with Python SDK autocompletion
- **5 starter templates** (minimal, web service, database, Python venv, download+extract)
- **Manifest validation** — catches errors before deploy
- **Deploy/Undeploy** — merge your dev app into the live catalog for testing
- **Dockerfile import** with live chain resolution progress
- **Unraid XML import** — convert Unraid Community Apps templates
- **Export** — download as a zip ready for catalog submission

## The Security Comparison

| | Community Scripts | PVE App Store |
|---|---|---|
| **Install code runs on** | Proxmox host (root) | Inside LXC container |
| **Blast radius if compromised** | Entire node | Single container |
| **Scripts fetched at runtime** | 8 remote bash files per install | Catalog cloned once via git |
| **Review before execute** | No (curl pipe bash) | Yes (web UI editor) |
| **Permission model** | None | Declared in app.yml |
| **Script language** | Bash (8 chained files) | Python (1 file + SDK) |
| **Auditability** | Read every bash chain | Read YAML manifest |
| **Dependency on GitHub during install** | Yes, every run | No, catalog is local |
| **Hardware edge cases** | Silent failures | Script visible and editable |

## What's the Same

Let's be honest about shared risks:

- **Supply chain attacks on the catalog repo** — a malicious PR could add a harmful app. Same as any open-source project. The permission manifest helps reviewers catch suspicious capabilities, but it's not a silver bullet.
- **Complex apps can still break** — if upstream packages change or disappear, installs fail. The structured SDK makes debugging easier than bash chains, but the risk exists.
- **You should still read the script** — the permission manifest and web editor make this practical, but "trust but verify" still applies.

The fundamental difference is **blast radius**. When a community script goes wrong, you can lose your hypervisor. When a PVE App Store script goes wrong, you lose a container.

## Getting Started

The PVE App Store is a single Go binary that runs as a systemd service on your Proxmox host:

```bash
bash <(curl -fsSL https://raw.githubusercontent.com/battlewithbytes/pve-appstore/main/deploy/install.sh)
```

Yes, that's a `curl | bash` one-liner for the installer — but this is the **only** script that runs on the host, it's a one-time operation, and it installs a compiled Go binary. After that, every app deployment runs inside containers.

The web UI is available at `https://your-proxmox-ip:7443`. Browse apps, customize inputs, review scripts, and deploy — all from your browser.

## What's Next

- **M3: Security hardening** — enforcing the permission manifest at runtime, not just as documentation
- **M4: GPU passthrough** — first-class NVIDIA/Intel GPU support with automatic detection
- **Catalog growth** — more apps, community contributions, and a submission workflow

The code is open source. Read every line if you want — that's the point.

## Related Resources

- **PVE App Store**: [GitHub Repository](https://github.com/battlewithbytes/pve-appstore)
- **XDA Article**: [I love Proxmox community scripts, but a single command executes 8 remote scripts as root](https://www.xda-developers.com/love-proxmox-community-scripts-one-commands-scripts-root/)
- **Proxmox Community Scripts**: [GitHub Repository](https://github.com/community-scripts/ProxmoxVE)
- **Proxmox VE API**: [Official Documentation](https://pve.proxmox.com/pve-docs/api-viewer/)
