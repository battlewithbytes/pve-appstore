package installer

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/crypto/bcrypt"

	"github.com/inertz/pve-appstore/internal/config"
)

const sudoersContent = `# PVE App Store — managed sudoers file
# Do not edit manually; regenerated by 'pve-appstore install'
#
# Only pct exec and pct push require sudo — all other container lifecycle
# operations (create, start, stop, destroy, status) use the Proxmox REST API
# via API token. See SECURITY.md for rationale.

appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/sbin/pct exec *
appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/sbin/pct push *
`

const systemdUnit = `[Unit]
Description=PVE App Store
Documentation=https://github.com/inertz/pve-appstore
After=network-online.target pve-cluster.service pvedaemon.service
Wants=network-online.target
Requires=pve-cluster.service

[Service]
Type=simple
User=appstore
Group=appstore
ExecStart=/opt/pve-appstore/pve-appstore serve --config /etc/pve-appstore/config.yml
Restart=on-failure
RestartSec=5

# Security hardening
NoNewPrivileges=no
ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
ReadWritePaths=/var/lib/pve-appstore /var/log/pve-appstore

# Environment
Environment=HOME=/var/lib/pve-appstore

[Install]
WantedBy=multi-user.target
`

// ApplySystem executes all system changes after the TUI completes.
func ApplySystem(answers *InstallerAnswers, res *DiscoveredResources) error {
	nums, err := answers.ParseNumerics()
	if err != nil {
		return fmt.Errorf("invalid input: %w", err)
	}

	steps := []struct {
		name string
		fn   func() error
	}{
		{"Creating Proxmox pool", func() error { return createPool(answers) }},
		{"Setting up Proxmox API token", func() error { return createAPIToken(answers, res) }},
		{"Creating system user", createSystemUser},
		{"Creating directories", createDirectories},
		{"Writing configuration", func() error { return writeConfig(answers, nums, res) }},
		{"Installing sudoers", installSudoers},
		{"Installing systemd unit", installSystemdUnit},
		{"Starting service", startService},
	}

	for _, step := range steps {
		fmt.Printf("  → %s...\n", step.name)
		if err := step.fn(); err != nil {
			return fmt.Errorf("%s: %w", step.name, err)
		}
	}

	return nil
}

func createPool(answers *InstallerAnswers) error {
	if answers.PoolChoice != "__new__" {
		return nil // using existing pool
	}

	poolName := answers.NewPool
	cmd := exec.Command("pvesh", "create", "/pools", "--poolid", poolName)
	if out, err := cmd.CombinedOutput(); err != nil {
		// Pool might already exist, that's fine
		if strings.Contains(string(out), "already exists") {
			return nil
		}
		return fmt.Errorf("pvesh create pool: %s: %w", string(out), err)
	}
	return nil
}

func createAPIToken(answers *InstallerAnswers, res *DiscoveredResources) error {
	if !answers.AutoCreateToken {
		return nil // user provided manual token
	}

	pool := answers.EffectivePool()
	node := res.NodeName

	// 1. Create user (ignore if exists)
	exec.Command("pveum", "user", "add", "appstore@pve").CombinedOutput()

	// 2. Create custom role with least-privilege permissions
	perms := strings.Join([]string{
		"VM.Allocate",
		"VM.Config.Disk",
		"VM.Config.CPU",
		"VM.Config.Memory",
		"VM.Config.Network",
		"VM.Config.Options",
		"VM.PowerMgmt",
		"VM.Console",
		"VM.Monitor",
		"Datastore.AllocateSpace",
		"Datastore.Audit",
		"Pool.Audit",
		"Pool.Allocate",
		"Sys.Audit",
		"Sys.Modify",
	}, ",")
	exec.Command("pveum", "role", "add", "AppStoreRole", "--privs", perms).CombinedOutput()

	// 3. Assign role on pool path
	exec.Command("pveum", "acl", "modify", "/pool/"+pool, "--roles", "AppStoreRole", "--users", "appstore@pve").CombinedOutput()

	// 4. Assign read on local node
	exec.Command("pveum", "acl", "modify", "/nodes/"+node, "--roles", "PVEAuditor", "--users", "appstore@pve").CombinedOutput()

	// 5. Assign storage access
	exec.Command("pveum", "acl", "modify", "/storage/"+answers.Storage, "--roles", "AppStoreRole", "--users", "appstore@pve").CombinedOutput()

	// 6. Create API token (privsep=0 so token inherits user's permissions)
	out, err := exec.Command("pveum", "user", "token", "add", "appstore@pve", "appstore", "--privsep", "0", "--output-format", "json").CombinedOutput()
	if err != nil {
		// Token might already exist; try to remove and recreate
		exec.Command("pveum", "user", "token", "remove", "appstore@pve", "appstore").CombinedOutput()
		out, err = exec.Command("pveum", "user", "token", "add", "appstore@pve", "appstore", "--privsep", "0", "--output-format", "json").CombinedOutput()
		if err != nil {
			return fmt.Errorf("creating API token: %s: %w", string(out), err)
		}
	}

	// Parse token from output — pveum outputs the full token value
	// The output contains the token secret in a "value" field
	tokenValue := extractTokenValue(string(out))
	answers.TokenID = "appstore@pve!appstore"
	answers.TokenSecret = tokenValue

	return nil
}

// extractTokenValue parses the token secret from pveum output.
func extractTokenValue(output string) string {
	// pveum outputs JSON with "value" field or plain text with the token
	// Try to find the UUID-like token value
	for _, line := range strings.Split(output, "\n") {
		line = strings.TrimSpace(line)
		// Look for UUID pattern in the output
		if len(line) == 36 && strings.Count(line, "-") == 4 {
			return line
		}
		// JSON format: look for "value" field
		if strings.Contains(line, "value") {
			parts := strings.SplitN(line, ":", 2)
			if len(parts) == 2 {
				val := strings.TrimSpace(parts[1])
				val = strings.Trim(val, `",' `)
				if val != "" {
					return val
				}
			}
		}
		// Full token format from JSON: strip quotes/commas
		cleaned := strings.Trim(line, `"}, `)
		if len(cleaned) == 36 && strings.Count(cleaned, "-") == 4 {
			return cleaned
		}
	}
	return strings.TrimSpace(output)
}

func createSystemUser() error {
	// Check if user already exists
	if _, err := exec.Command("id", config.ServiceUser).Output(); err == nil {
		return nil // user exists
	}

	cmd := exec.Command("useradd",
		"--system",
		"--no-create-home",
		"--shell", "/usr/sbin/nologin",
		config.ServiceUser,
	)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}
	return nil
}

func createDirectories() error {
	dirs := []struct {
		path  string
		owner string
		mode  os.FileMode
	}{
		{"/etc/pve-appstore", "root", 0750},
		{config.DefaultDataDir, config.ServiceUser, 0750},
		{config.DefaultLogDir, config.ServiceUser, 0750},
		{config.DefaultInstallDir, "root", 0755},
	}

	for _, d := range dirs {
		if err := os.MkdirAll(d.path, d.mode); err != nil {
			return fmt.Errorf("creating %s: %w", d.path, err)
		}
		// Set ownership
		cmd := exec.Command("chown", d.owner+":"+config.ServiceGroup, d.path)
		cmd.CombinedOutput() // best-effort; appstore group may not exist yet for /etc dir
	}

	return nil
}

func writeConfig(answers *InstallerAnswers, nums *ParsedNumerics, res *DiscoveredResources) error {
	cfg := &config.Config{
		NodeName: res.NodeName,
		Pool:     answers.EffectivePool(),
		Storage:  answers.Storage,
		Bridge:   answers.Bridge,
		Defaults: config.ResourceConfig{
			Cores:    nums.Cores,
			MemoryMB: nums.MemoryMB,
			DiskGB:   nums.DiskGB,
		},
		Security: config.SecurityConfig{
			UnprivilegedOnly: answers.UnprivilegedOnly,
			AllowedFeatures:  []string{"nesting", "keyctl", "fuse"},
		},
		Service: config.ServiceConfig{
			BindAddress: answers.BindAddress,
			Port:        nums.Port,
		},
		Auth: config.AuthConfig{
			Mode: answers.AuthMode,
		},
		Proxmox: config.ProxmoxConfig{
			AutoCreated:   answers.AutoCreateToken,
			TokenID:       answers.TokenID,
			TokenSecret:   answers.TokenSecret,
			BaseURL:       fmt.Sprintf("https://%s:8006", res.NodeName),
			TLSSkipVerify: true,
		},
		Catalog: config.CatalogConfig{
			URL:     answers.CatalogURL,
			Branch:  answers.Branch,
			Refresh: answers.Refresh,
		},
		GPU: config.GPUConfig{
			Enabled:        answers.GPUEnabled,
			Policy:         answers.GPUPolicy,
			AllowedDevices: answers.GPUDevices,
		},
	}

	// Hash password if set
	if answers.AuthMode == config.AuthModePassword && answers.Password != "" {
		hash, err := bcrypt.GenerateFromPassword([]byte(answers.Password), bcrypt.DefaultCost)
		if err != nil {
			return fmt.Errorf("hashing password: %w", err)
		}
		cfg.Auth.PasswordHash = string(hash)
	}

	path := config.DefaultConfigPath
	if err := cfg.Save(path); err != nil {
		return err
	}

	// Set ownership: root:appstore 0640
	exec.Command("chown", "root:"+config.ServiceGroup, path).Run()
	exec.Command("chmod", "0640", path).Run()

	return nil
}

func installSudoers() error {
	tmpPath := "/tmp/pve-appstore-sudoers"
	targetPath := "/etc/sudoers.d/pve-appstore"

	if err := os.WriteFile(tmpPath, []byte(sudoersContent), 0440); err != nil {
		return fmt.Errorf("writing temp sudoers: %w", err)
	}
	defer os.Remove(tmpPath)

	// Validate with visudo
	if out, err := exec.Command("visudo", "-cf", tmpPath).CombinedOutput(); err != nil {
		return fmt.Errorf("sudoers validation failed: %s: %w", string(out), err)
	}

	// Copy to target
	data, _ := os.ReadFile(tmpPath)
	if err := os.WriteFile(targetPath, data, 0440); err != nil {
		return fmt.Errorf("writing sudoers: %w", err)
	}

	return nil
}

func installSystemdUnit() error {
	unitPath := "/etc/systemd/system/pve-appstore.service"

	if err := os.WriteFile(unitPath, []byte(systemdUnit), 0644); err != nil {
		return fmt.Errorf("writing unit file: %w", err)
	}

	if out, err := exec.Command("systemctl", "daemon-reload").CombinedOutput(); err != nil {
		return fmt.Errorf("daemon-reload: %s: %w", string(out), err)
	}

	if out, err := exec.Command("systemctl", "enable", "pve-appstore.service").CombinedOutput(); err != nil {
		return fmt.Errorf("enable service: %s: %w", string(out), err)
	}

	return nil
}

func startService() error {
	// Copy binary to install dir if running from a different location
	exe, err := os.Executable()
	if err == nil && exe != config.DefaultInstallDir+"/pve-appstore" {
		exec.Command("cp", exe, config.DefaultInstallDir+"/pve-appstore").Run()
		exec.Command("chmod", "0755", config.DefaultInstallDir+"/pve-appstore").Run()
	}

	// Copy SPA assets if they exist near the running binary
	copySPAAssets(exe)

	if out, err := exec.Command("systemctl", "start", "pve-appstore.service").CombinedOutput(); err != nil {
		return fmt.Errorf("start service: %s: %w", string(out), err)
	}

	return nil
}

// copySPAAssets copies web/frontend/dist to the install directory.
func copySPAAssets(exePath string) {
	// Look for SPA dist relative to the binary or CWD
	candidates := []string{
		"web/frontend/dist",
	}

	// Also try relative to where the binary lives
	if exePath != "" {
		dir := filepath.Dir(exePath)
		candidates = append(candidates, filepath.Join(dir, "web/frontend/dist"))
	}

	for _, src := range candidates {
		if info, err := os.Stat(src); err == nil && info.IsDir() {
			dst := config.DefaultInstallDir + "/web/frontend/dist"
			os.MkdirAll(filepath.Dir(dst), 0755)
			exec.Command("cp", "-r", src, dst).Run()
			exec.Command("chown", "-R", "root:"+config.ServiceGroup, config.DefaultInstallDir+"/web").Run()
			return
		}
	}
}
