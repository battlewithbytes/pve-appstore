package installer

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"golang.org/x/crypto/bcrypt"

	"github.com/battlewithbytes/pve-appstore/internal/config"
	"github.com/battlewithbytes/pve-appstore/internal/ui"
	"github.com/battlewithbytes/pve-appstore/internal/updater"
)

const sudoersContent = `# PVE App Store — managed sudoers file
# Do not edit manually; regenerated by 'pve-appstore install'
#
# pct exec/push: provisioning and shell access
# pct set: device passthrough (GPU) — the Proxmox API restricts dev* to root@pam,
#   so we apply device config post-creation via pct set on the host.
# tee -a: append raw lxc.* lines to /etc/pve/lxc/*.conf (extra_config)
# mkdir -p: create directories on host storage pools for bind mounts
# chown: fix ownership on bind mount paths for unprivileged containers
# All other container lifecycle ops use the Proxmox REST API via API token.

appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/sbin/pct exec *
appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/sbin/pct push *
appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/sbin/pct set *
appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/bin/tee -a /etc/pve/lxc/*
appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/bin/mkdir -p *
appstore ALL=(root) NOPASSWD: /usr/bin/nsenter --mount=/proc/1/ns/mnt -- /usr/bin/chown *
appstore ALL=(root) NOPASSWD: /opt/pve-appstore/update.sh
`

const systemdUnit = `[Unit]
Description=PVE App Store
Documentation=https://github.com/battlewithbytes/pve-appstore
After=network-online.target pve-cluster.service pvedaemon.service
Wants=network-online.target
Requires=pve-cluster.service

[Service]
Type=simple
User=appstore
Group=appstore
ExecStart=/opt/pve-appstore/pve-appstore serve --config /etc/pve-appstore/config.yml
Restart=on-failure
RestartSec=5

# Security hardening
NoNewPrivileges=no
ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
ReadWritePaths=/var/lib/pve-appstore /var/log/pve-appstore

# Environment
Environment=HOME=/var/lib/pve-appstore

[Install]
WantedBy=multi-user.target
`

// ApplySystem executes all system changes after the TUI completes.
func ApplySystem(answers *InstallerAnswers, res *DiscoveredResources, port int) error {
	steps := []struct {
		name string
		fn   func() error
	}{
		{"Creating Proxmox pool", func() error { return createPool(answers) }},
		{"Setting up Proxmox API token", func() error { return createAPIToken(answers, res) }},
		{"Creating system user", createSystemUser},
		{"Creating directories", createDirectories},
		{"Writing configuration", func() error { return writeConfig(answers, port, res) }},
		{"Installing sudoers", installSudoers},
		{"Installing update script", func() error { return updater.DeployUpdateScript() }},
		{"Installing systemd unit", installSystemdUnit},
		{"Starting service", startService},
	}

	for _, step := range steps {
		fmt.Printf("  %s %s...", ui.Cyan.Render("→"), step.name)
		if err := step.fn(); err != nil {
			fmt.Printf("\r  %s %s   \n", ui.Red.Render("✗"), step.name)
			return fmt.Errorf("%s: %w", step.name, err)
		}
		fmt.Printf("\r  %s %s   \n", ui.Green.Render("✓"), step.name)
	}

	return nil
}

func createPool(answers *InstallerAnswers) error {
	if answers.PoolChoice != "__new__" {
		return nil // using existing pool
	}

	poolName := answers.NewPool
	cmd := exec.Command("pvesh", "create", "/pools", "--poolid", poolName)
	if out, err := cmd.CombinedOutput(); err != nil {
		// Pool might already exist, that's fine
		if strings.Contains(string(out), "already exists") {
			return nil
		}
		return fmt.Errorf("pvesh create pool: %s: %w", string(out), err)
	}
	return nil
}

func createAPIToken(answers *InstallerAnswers, res *DiscoveredResources) error {
	if !answers.AutoCreateToken {
		return nil // user provided manual token
	}

	pool := answers.EffectivePool()
	node := res.NodeName

	// 1. Create user (ignore if exists)
	exec.Command("pveum", "user", "add", "appstore@pve").CombinedOutput()

	// 2. Create custom role with least-privilege permissions
	perms := strings.Join([]string{
		"VM.Allocate",
		"VM.Audit",
		"VM.Config.Disk",
		"VM.Config.CPU",
		"VM.Config.Memory",
		"VM.Config.Network",
		"VM.Config.Options",
		"VM.PowerMgmt",
		"VM.Console",
		"Datastore.AllocateSpace",
		"Datastore.Audit",
		"Pool.Audit",
		"Pool.Allocate",
		"SDN.Use",
		"Sys.Audit",
		"Sys.Modify",
	}, ",")
	exec.Command("pveum", "role", "add", "AppStoreRole", "--privs", perms).CombinedOutput()
	// Update privs in case role already existed with different permissions
	exec.Command("pveum", "role", "modify", "AppStoreRole", "--privs", perms).CombinedOutput()

	// 3. Assign role on pool path
	exec.Command("pveum", "acl", "modify", "/pool/"+pool, "--roles", "AppStoreRole", "--users", "appstore@pve").CombinedOutput()

	// 4. Assign role on /vms path — Proxmox checks VM.Config.* on /vms/{vmid}
	// during container creation (before the VM is added to the pool)
	exec.Command("pveum", "acl", "modify", "/vms", "--roles", "AppStoreRole", "--users", "appstore@pve").CombinedOutput()

	// 5. Assign read on local node
	exec.Command("pveum", "acl", "modify", "/nodes/"+node, "--roles", "PVEAuditor", "--users", "appstore@pve").CombinedOutput()

	// 6. Assign SDN access for network bridges
	exec.Command("pveum", "acl", "modify", "/sdn/zones", "--roles", "AppStoreRole", "--users", "appstore@pve").CombinedOutput()

	// 7. Assign storage access on all selected storages + local (for OS templates)
	storageSet := make(map[string]bool)
	storageSet["local"] = true // OS templates typically live on local storage
	for _, st := range answers.Storages {
		storageSet[st] = true
	}
	for st := range storageSet {
		exec.Command("pveum", "acl", "modify", "/storage/"+st, "--roles", "AppStoreRole", "--users", "appstore@pve").CombinedOutput()
	}

	// 8. Create API token (privsep=0 so token inherits user's permissions)
	out, err := exec.Command("pveum", "user", "token", "add", "appstore@pve", "appstore", "--privsep", "0", "--output-format", "json").CombinedOutput()
	if err != nil {
		// Token might already exist; try to remove and recreate
		exec.Command("pveum", "user", "token", "remove", "appstore@pve", "appstore").CombinedOutput()
		out, err = exec.Command("pveum", "user", "token", "add", "appstore@pve", "appstore", "--privsep", "0", "--output-format", "json").CombinedOutput()
		if err != nil {
			return fmt.Errorf("creating API token: %s: %w", string(out), err)
		}
	}

	// Parse token from output — pveum outputs the full token value
	// The output contains the token secret in a "value" field
	tokenValue := extractTokenValue(string(out))
	answers.TokenID = "appstore@pve!appstore"
	answers.TokenSecret = tokenValue

	return nil
}

// extractTokenValue parses the token secret from pveum JSON output.
// Expected format: {"full-tokenid":"appstore@pve!appstore","info":{"privsep":"0"},"value":"<uuid>"}
func extractTokenValue(output string) string {
	var parsed struct {
		Value string `json:"value"`
	}
	if err := json.Unmarshal([]byte(strings.TrimSpace(output)), &parsed); err == nil && parsed.Value != "" {
		return parsed.Value
	}
	// Fallback: scan for UUID-like token on its own line
	for _, line := range strings.Split(output, "\n") {
		line = strings.TrimSpace(line)
		if len(line) == 36 && strings.Count(line, "-") == 4 {
			return line
		}
	}
	return strings.TrimSpace(output)
}

func createSystemUser() error {
	// Check if user already exists
	if _, err := exec.Command("id", config.ServiceUser).Output(); err == nil {
		return nil // user exists
	}

	cmd := exec.Command("useradd",
		"--system",
		"--no-create-home",
		"--shell", "/usr/sbin/nologin",
		config.ServiceUser,
	)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(out), err)
	}
	return nil
}

func createDirectories() error {
	dirs := []struct {
		path  string
		owner string
		mode  os.FileMode
	}{
		{"/etc/pve-appstore", "root", 0750},
		{config.DefaultDataDir, config.ServiceUser, 0750},
		{config.DefaultDataDir + "/tmp", config.ServiceUser, 0750},
		{config.DefaultLogDir, config.ServiceUser, 0750},
		{config.DefaultInstallDir, "root", 0755},
	}

	for _, d := range dirs {
		if err := os.MkdirAll(d.path, d.mode); err != nil {
			return fmt.Errorf("creating %s: %w", d.path, err)
		}
		// Set ownership
		cmd := exec.Command("chown", d.owner+":"+config.ServiceGroup, d.path)
		cmd.CombinedOutput() // best-effort; appstore group may not exist yet for /etc dir
	}

	return nil
}

func writeConfig(answers *InstallerAnswers, port int, res *DiscoveredResources) error {
	cores, err := strconv.Atoi(answers.CoresStr)
	if err != nil {
		return fmt.Errorf("invalid default cores: %w", err)
	}
	memoryMB, err := strconv.Atoi(answers.MemoryMBStr)
	if err != nil {
		return fmt.Errorf("invalid default memory: %w", err)
	}
	diskGB, err := strconv.Atoi(answers.DiskGBStr)
	if err != nil {
		return fmt.Errorf("invalid default disk: %w", err)
	}

	cfg := &config.Config{
		NodeName: res.NodeName,
		Pool:     answers.EffectivePool(),
		Storages: answers.Storages,
		Bridges:  answers.Bridges,
		Defaults: config.ResourceConfig{
			Cores:    cores,
			MemoryMB: memoryMB,
			DiskGB:   diskGB,
		},
		Security: config.SecurityConfig{
			UnprivilegedOnly: answers.UnprivilegedOnly,
			AllowedFeatures:  []string{"nesting", "keyctl", "fuse"},
		},
		Service: config.ServiceConfig{
			BindAddress: answers.BindAddress,
			Port:        port,
		},
		Auth: config.AuthConfig{
			Mode: answers.AuthMode,
		},
		Proxmox: config.ProxmoxConfig{
			AutoCreated:   answers.AutoCreateToken,
			TokenID:       answers.TokenID,
			TokenSecret:   answers.TokenSecret,
			BaseURL:       fmt.Sprintf("https://%s:8006", res.NodeName),
			TLSSkipVerify: true,
		},
		Catalog: config.CatalogConfig{
			URL:     answers.CatalogURL,
			Branch:  answers.Branch,
			Refresh: answers.Refresh,
		},
		GPU: config.GPUConfig{
			Enabled:        answers.GPUEnabled,
			Policy:         answers.GPUPolicy,
			AllowedDevices: answers.GPUDevices,
		},
	}

	// Hash password if set
	if answers.AuthMode == config.AuthModePassword && answers.Password != "" {
		hash, err := bcrypt.GenerateFromPassword([]byte(answers.Password), bcrypt.DefaultCost)
		if err != nil {
			return fmt.Errorf("hashing password: %w", err)
		}
		cfg.Auth.PasswordHash = string(hash)
	}
	// Generate HMAC secret if empty (will be saved when config is saved)
	if cfg.Auth.HMACSecret == "" {
		secretBytes := make([]byte, 32)
		if _, err := rand.Read(secretBytes); err != nil {
			return fmt.Errorf("failed to generate HMAC secret: %w", err)
		}
		cfg.Auth.HMACSecret = hex.EncodeToString(secretBytes)
	}

	path := config.DefaultConfigPath
	if err := cfg.Save(path); err != nil {
		return err
	}

	// Set ownership: root:appstore 0640
	exec.Command("chown", "root:"+config.ServiceGroup, path).Run()
	exec.Command("chmod", "0640", path).Run()

	return nil
}

func installSudoers() error {
	tmpPath := "/tmp/pve-appstore-sudoers"
	targetPath := "/etc/sudoers.d/pve-appstore"

	if err := os.WriteFile(tmpPath, []byte(sudoersContent), 0440); err != nil {
		return fmt.Errorf("writing temp sudoers: %w", err)
	}
	defer os.Remove(tmpPath)

	// Validate with visudo
	if out, err := exec.Command("visudo", "-cf", tmpPath).CombinedOutput(); err != nil {
		return fmt.Errorf("sudoers validation failed: %s: %w", string(out), err)
	}

	// Copy to target
	data, _ := os.ReadFile(tmpPath)
	if err := os.WriteFile(targetPath, data, 0440); err != nil {
		return fmt.Errorf("writing sudoers: %w", err)
	}

	return nil
}

func installSystemdUnit() error {
	unitPath := "/etc/systemd/system/pve-appstore.service"

	if err := os.WriteFile(unitPath, []byte(systemdUnit), 0644); err != nil {
		return fmt.Errorf("writing unit file: %w", err)
	}

	if out, err := exec.Command("systemctl", "daemon-reload").CombinedOutput(); err != nil {
		return fmt.Errorf("daemon-reload: %s: %w", string(out), err)
	}

	if out, err := exec.Command("systemctl", "enable", "pve-appstore.service").CombinedOutput(); err != nil {
		return fmt.Errorf("enable service: %s: %w", string(out), err)
	}

	return nil
}

func startService() error {
	// Copy binary to install dir if running from a different location
	exe, err := os.Executable()
	if err == nil && exe != config.DefaultInstallDir+"/pve-appstore" {
		exec.Command("cp", exe, config.DefaultInstallDir+"/pve-appstore").Run()
		exec.Command("chmod", "0755", config.DefaultInstallDir+"/pve-appstore").Run()
	}

	if out, err := exec.Command("systemctl", "start", "pve-appstore.service").CombinedOutput(); err != nil {
		return fmt.Errorf("start service: %s: %w", string(out), err)
	}

	return nil
}